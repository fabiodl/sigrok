-------------------------------------------------------------------------------
HACKING
-------------------------------------------------------------------------------

Coding style
------------

This project is programmed using the Linux kernel coding style, see
http://lxr.linux.no/linux/Documentation/CodingStyle for details.

Please use the same style for any code contributions, thanks!

As an exception, the Qt GUI application uses the usual Qt / C++ conventions
of mixed-case variable names, capital letters for class names etc. However,
please do use an indention of one tab here too, just as with the other code.

The GTK+ GUI also uses the usual GTK+ naming conventions and so on, as far
as it makes sense, but otherwise also follows the kernel coding style.
This includes using one tab for indentation.

The Python decoders should follow the usual Python conventions and use
Python idioms as far as it makes sense. The coding style should mostly follow
the Python PEP-8, which includes the convention of 4 spaces for indentation.
See http://www.python.org/dev/peps/pep-0008/ for details.


Random notes
------------

 - Consistently use g_try_malloc() / g_try_malloc0() in libsigrok. Do not use
   standard malloc()/calloc() if it can be avoided (sometimes other libs such
   as libftdi can return malloc()'d memory, for example).

 - Always properly match allocations with the proper *free() functions. If
   glib's g_try_malloc()/g_try_malloc0() was used, use g_free() to free the
   memory. Otherwise use standard free(). Never use the wrong function!

 - Never use g_malloc() or g_malloc0() in libsigrok*. These functions do not
   return NULL if not enough memory is available but rather lead to an
   exit() or segfault instead. This behaviour is not acceptable for libsigrok*.
   Use g_try_malloc()/g_try_malloc0() instead and check the return value.

 - libsigrok* should never print any messages (neither to stdout nor stderr nor
   elsewhere) "manually" via e.g. printf() or g_log() or similar functions.
   Only sr_err()/sr_warn()/sr_info()/sr_dbg() should be used (or their
   equivalents in the other libs such as srd_err() or srf_err()).

 - Consistently use the same naming convention for #include guards in headers:
   <PROJECTNAME>_<PATH_TO_FILE>_<FILE>
   This ensures that all #include guards are always unique and consistent.
   Examples: LIBSIGROK_SIGROK_H, LIBSIGROK_HARDWARE_ASIX_SIGMA_ASIX_SIGMA_H,
             SIGROK_GTK_GTKCELLRENDERERSIGNAL_H, SIGROK_QT_MAINWINDOW_H

 - Consistently use the same naming convention for API functions:
   <libprefix>_<groupname>_<action>().

   Examples:
     srd_log_loglevel_set(), srd_log_loglevel_get(), srd_log_handler_set(),
     srd_log_handler_set_default(), and so on.
   Or:
     sr_session_new(), sr_session_destroy(), sr_session_load(), and so on.

   Getter/setter function names should usually end with "_get" or "_set".
   Functions creating new "objects" should end with "_new".
   Functions destroying "objects" should end with "_destroy".


Release engineering
-------------------

See

 http://sigrok.org/wiki/Developers/Release_process

for a list of items that need to be done when releasing a new tarball.


Creating a Windows installer
----------------------------

In order to create a self-contained Windows installer EXE file for sigrok,
you can do the following (currently must be done on a Windows/MinGW system):

Build and install libsigrok, libsigrokdecode, sigrok-cli, sigrok-gtk, and
sigrok-qt into /usr/local.

Download the Windows Python 3.2 installer into c:\:

 $ cd /c
 $ wget http://www.python.org/ftp/python/3.2/python-3.2.msi

Create the installer (assumes all required libs in certain directories) via:

 $ cd contrib/nsis
 $ makensis sigrok.nsi

This will create a sigrok-installer-$VERSION.exe self-extracting installer.

